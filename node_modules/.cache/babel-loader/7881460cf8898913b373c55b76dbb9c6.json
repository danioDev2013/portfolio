{"ast":null,"code":"import { useRef, useState, useEffect, createContext, createElement, useCallback, useDebugValue, useContext } from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nconst hasInitialValue = atom => 'init' in atom;\n\nconst createState = (initialValues, newAtomReceiver) => {\n  const state = {\n    n: newAtomReceiver,\n    v: 0,\n    a: new WeakMap(),\n    m: new WeakMap(),\n    p: new Set()\n  };\n\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        d: new Map()\n      };\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n      }\n\n      state.a.set(atom, atomState);\n    }\n  }\n\n  return state;\n};\n\nconst getAtomState = (state, atom) => state.a.get(atom);\n\nconst wipAtomState = (state, atom, dependencies) => {\n  const atomState = getAtomState(state, atom);\n\n  const nextAtomState = _extends({\n    r: 0\n  }, atomState, {\n    d: dependencies ? new Map(Array.from(dependencies).map(a => {\n      var _getAtomState$r, _getAtomState;\n\n      return [a, (_getAtomState$r = (_getAtomState = getAtomState(state, a)) == null ? void 0 : _getAtomState.r) != null ? _getAtomState$r : 0];\n    })) : atomState ? atomState.d : new Map()\n  });\n\n  if (!atomState && hasInitialValue(atom)) {\n    nextAtomState.v = atom.init;\n  }\n\n  return [nextAtomState, atomState == null ? void 0 : atomState.d];\n};\n\nconst setAtomValue = (state, atom, value, dependencies, promise) => {\n  const [atomState, prevDependencies] = wipAtomState(state, atom, dependencies);\n\n  if (promise && promise !== (atomState == null ? void 0 : atomState.p)) {\n    // newer async read is running, not updating\n    return;\n  }\n\n  delete atomState.e; // read error\n\n  delete atomState.p; // read promise\n\n  delete atomState.i; // invalidated revision\n\n  if (!('v' in atomState) || !Object.is(atomState.v, value)) {\n    atomState.v = value;\n    ++atomState.r; // increment revision\n  }\n\n  commitAtomState(state, atom, atomState);\n  mountDependencies(state, atom, atomState, prevDependencies);\n};\n\nconst setAtomReadError = (state, atom, error, dependencies, promise) => {\n  const [atomState, prevDependencies] = wipAtomState(state, atom, dependencies);\n\n  if (promise && promise !== (atomState == null ? void 0 : atomState.p)) {\n    // newer async read is running, not updating\n    return;\n  }\n\n  delete atomState.p; // read promise\n\n  delete atomState.i; // invalidated revision\n\n  atomState.e = error; // read error\n\n  commitAtomState(state, atom, atomState);\n  mountDependencies(state, atom, atomState, prevDependencies);\n};\n\nconst setAtomReadPromise = (state, atom, promise, dependencies) => {\n  const [atomState, prevDependencies] = wipAtomState(state, atom, dependencies);\n  atomState.p = promise; // read promise\n\n  commitAtomState(state, atom, atomState);\n  mountDependencies(state, atom, atomState, prevDependencies);\n};\n\nconst setAtomInvalidated = (state, atom) => {\n  const [atomState] = wipAtomState(state, atom);\n  atomState.i = atomState.r; // invalidated revision\n\n  commitAtomState(state, atom, atomState);\n};\n\nconst setAtomWritePromise = (state, atom, promise) => {\n  const [atomState] = wipAtomState(state, atom);\n\n  if (promise) {\n    atomState.w = promise;\n  } else {\n    delete atomState.w; // write promise\n  }\n\n  commitAtomState(state, atom, atomState);\n};\n\nconst scheduleReadAtomState = (state, atom, promise) => {\n  promise.then(() => {\n    readAtomState(state, atom, true);\n  });\n};\n\nconst readAtomState = (state, atom, force) => {\n  if (!force) {\n    const atomState = getAtomState(state, atom);\n\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const aState = getAtomState(state, a);\n\n          if (aState && !aState.e && // no read error\n          !aState.p && // no read promise\n          aState.r === aState.i // revision is invalidated\n          ) {\n              readAtomState(state, a, true);\n            }\n        }\n      });\n\n      if (Array.from(atomState.d.entries()).every(([a, r]) => {\n        const aState = getAtomState(state, a);\n        return aState && !aState.e && // no read error\n        !aState.p && // no read promise\n        aState.r !== aState.i && // revision is not invalidated\n        aState.r === r // revision is equal to the last one\n        ;\n      })) {\n        return atomState;\n      }\n    }\n  }\n\n  let error;\n  let promise;\n  let value;\n  const dependencies = new Set();\n\n  try {\n    const promiseOrValue = atom.read(a => {\n      dependencies.add(a);\n\n      if (a !== atom) {\n        const aState = readAtomState(state, a);\n\n        if (aState.e) {\n          throw aState.e; // read error\n        }\n\n        if (aState.p) {\n          throw aState.p; // read promise\n        }\n\n        return aState.v; // value\n      } // a === atom\n\n\n      const aState = getAtomState(state, a);\n\n      if (aState) {\n        if (aState.p) {\n          throw aState.p; // read promise\n        }\n\n        return aState.v; // value\n      }\n\n      if (hasInitialValue(a)) {\n        return a.init;\n      }\n\n      throw new Error('no atom init');\n    });\n\n    if (promiseOrValue instanceof Promise) {\n      promise = promiseOrValue.then(value => {\n        setAtomValue(state, atom, value, dependencies, promise);\n        flushPending(state);\n      }).catch(e => {\n        if (e instanceof Promise) {\n          scheduleReadAtomState(state, atom, e);\n          return e;\n        }\n\n        setAtomReadError(state, atom, e instanceof Error ? e : new Error(e), dependencies, promise);\n        flushPending(state);\n      });\n    } else {\n      value = promiseOrValue;\n    }\n  } catch (errorOrPromise) {\n    if (errorOrPromise instanceof Promise) {\n      scheduleReadAtomState(state, atom, errorOrPromise);\n      promise = errorOrPromise;\n    } else if (errorOrPromise instanceof Error) {\n      error = errorOrPromise;\n    } else {\n      error = new Error(errorOrPromise);\n    }\n  }\n\n  if (error) {\n    setAtomReadError(state, atom, error, dependencies);\n  } else if (promise) {\n    setAtomReadPromise(state, atom, promise, dependencies);\n  } else {\n    setAtomValue(state, atom, value, dependencies);\n  }\n\n  return getAtomState(state, atom);\n};\n\nconst readAtom = (state, readingAtom) => {\n  const atomState = readAtomState(state, readingAtom);\n  state.p.delete(readingAtom);\n  flushPending(state);\n  return atomState;\n};\n\nconst addAtom = (state, addingAtom) => {\n  let mounted = state.m.get(addingAtom);\n\n  if (!mounted) {\n    mounted = mountAtom(state, addingAtom);\n  }\n\n  flushPending(state);\n  return mounted;\n}; // XXX doesn't work with mutally dependent atoms\n\n\nconst canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.d.size || mounted.d.size === 1 && mounted.d.has(atom));\n\nconst delAtom = (state, deletingAtom) => {\n  const mounted = state.m.get(deletingAtom);\n\n  if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n    unmountAtom(state, deletingAtom);\n  }\n\n  flushPending(state);\n};\n\nconst invalidateDependents = (state, atom) => {\n  const mounted = state.m.get(atom);\n  mounted == null ? void 0 : mounted.d.forEach(dependent => {\n    if (dependent === atom) {\n      return;\n    }\n\n    setAtomInvalidated(state, dependent);\n    invalidateDependents(state, dependent);\n  });\n};\n\nconst writeAtomState = (state, atom, update, pendingPromises) => {\n  const isPendingPromisesExpired = !pendingPromises.length;\n  const atomState = getAtomState(state, atom);\n\n  if (atomState && atomState.w // write promise\n  ) {\n      const promise = atomState.w.then(() => {\n        writeAtomState(state, atom, update, pendingPromises);\n\n        if (isPendingPromisesExpired) {\n          flushPending(state);\n        }\n      });\n\n      if (!isPendingPromisesExpired) {\n        pendingPromises.push(promise);\n      }\n\n      return;\n    }\n\n  try {\n    const promiseOrVoid = atom.write(a => {\n      const aState = readAtomState(state, a);\n\n      if (aState.e) {\n        throw aState.e; // read error\n      }\n\n      if (aState.p) {\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          console.warn('Reading pending atom state in write operation. We throw a promise for now.', a);\n        }\n\n        throw aState.p; // read promise\n      }\n\n      if ('v' in aState) {\n        return aState.v; // value\n      }\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] no value found while reading atom in write operation. This probably a bug.', a);\n      }\n\n      throw new Error('no value found');\n    }, (a, v) => {\n      if (a === atom) {\n        setAtomValue(state, a, v);\n        invalidateDependents(state, a);\n      } else {\n        const isPendingPromisesExpired = !pendingPromises.length;\n        writeAtomState(state, a, v, pendingPromises);\n\n        if (isPendingPromisesExpired) {\n          flushPending(state);\n        }\n      }\n    }, update);\n\n    if (promiseOrVoid instanceof Promise) {\n      const promise = promiseOrVoid.then(() => {\n        setAtomWritePromise(state, atom);\n\n        if (isPendingPromisesExpired) {\n          flushPending(state);\n        }\n      });\n\n      if (!isPendingPromisesExpired) {\n        pendingPromises.push(promise);\n      }\n\n      setAtomWritePromise(state, atom, promise);\n    }\n  } catch (e) {\n    if (pendingPromises.length === 1) {\n      // still in sync, throw it right away\n      throw e;\n    } else if (!isPendingPromisesExpired) {\n      pendingPromises.push(new Promise((_resolve, reject) => {\n        reject(e);\n      }));\n    } else {\n      console.error('Uncaught exception: Use promise to catch error', e);\n    }\n  }\n};\n\nconst writeAtom = (state, writingAtom, update) => {\n  const pendingPromises = [Promise.resolve()];\n  writeAtomState(state, writingAtom, update, pendingPromises);\n  flushPending(state);\n\n  if (pendingPromises.length <= 1) {\n    pendingPromises.splice(0);\n  } else {\n    return new Promise((resolve, reject) => {\n      const loop = () => {\n        if (pendingPromises.length <= 1) {\n          pendingPromises.splice(0);\n          resolve();\n        } else {\n          Promise.all(pendingPromises).then(() => {\n            pendingPromises.splice(1);\n            flushPending(state);\n            loop();\n          }).catch(reject);\n        }\n      };\n\n      loop();\n    });\n  }\n};\n\nconst isActuallyWritableAtom = atom => !!atom.write;\n\nconst mountAtom = (state, atom, initialDependent) => {\n  // mount dependencies beforehand\n  const atomState = getAtomState(state, atom);\n\n  if (atomState) {\n    atomState.d.forEach((_, a) => {\n      if (a !== atom) {\n        // check if not mounted\n        if (!state.m.has(a)) {\n          mountAtom(state, a, atom);\n        }\n      }\n    });\n  } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    console.warn('[Bug] could not find atom state to mount', atom);\n  } // mount self\n\n\n  const mounted = {\n    d: new Set(initialDependent && [initialDependent]),\n    l: new Set(),\n    u: undefined\n  };\n  state.m.set(atom, mounted);\n\n  if (isActuallyWritableAtom(atom) && atom.onMount) {\n    const setAtom = update => writeAtom(state, atom, update);\n\n    mounted.u = atom.onMount(setAtom);\n  }\n\n  return mounted;\n};\n\nconst unmountAtom = (state, atom) => {\n  var _state$m$get; // unmount self\n\n\n  const onUnmount = (_state$m$get = state.m.get(atom)) == null ? void 0 : _state$m$get.u;\n\n  if (onUnmount) {\n    onUnmount();\n  }\n\n  state.m.delete(atom); // unmount dependencies afterward\n\n  const atomState = getAtomState(state, atom);\n\n  if (atomState) {\n    if (atomState.p && // read promise\n    typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] deleting atomState with read promise', atom);\n    }\n\n    atomState.d.forEach((_, a) => {\n      if (a !== atom) {\n        const mounted = state.m.get(a);\n\n        if (mounted) {\n          mounted.d.delete(atom);\n\n          if (canUnmountAtom(a, mounted)) {\n            unmountAtom(state, a);\n          }\n        }\n      }\n    });\n  } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    console.warn('[Bug] could not find atom state to unmount', atom);\n  }\n};\n\nconst mountDependencies = (state, atom, atomState, prevDependencies) => {\n  if (prevDependencies !== atomState.d) {\n    const dependencies = new Set(atomState.d.keys());\n\n    if (prevDependencies) {\n      prevDependencies.forEach((_, a) => {\n        const mounted = state.m.get(a);\n\n        if (dependencies.has(a)) {\n          // not changed\n          dependencies.delete(a);\n        } else if (mounted) {\n          mounted.d.delete(atom);\n\n          if (canUnmountAtom(a, mounted)) {\n            unmountAtom(state, a);\n          }\n        } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          console.warn('[Bug] a dependency is not mounted', a);\n        }\n      });\n    }\n\n    dependencies.forEach(a => {\n      const mounted = state.m.get(a);\n\n      if (mounted) {\n        const dependents = mounted.d;\n        dependents.add(atom);\n      } else {\n        mountAtom(state, a, atom);\n      }\n    });\n  }\n};\n\nconst commitAtomState = (state, atom, atomState) => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    Object.freeze(atomState);\n  }\n\n  const isNewAtom = state.n && !state.a.has(atom);\n  state.a.set(atom, atomState);\n\n  if (isNewAtom) {\n    state.n(atom);\n  }\n\n  ++state.v;\n  state.p.add(atom);\n};\n\nconst flushPending = state => {\n  state.p.forEach(atom => {\n    const mounted = state.m.get(atom);\n    mounted == null ? void 0 : mounted.l.forEach(listener => listener());\n  });\n  state.p.clear();\n};\n\nconst subscribeAtom = (state, atom, callback) => {\n  const mounted = addAtom(state, atom);\n  const listeners = mounted.l;\n  listeners.add(callback);\n  return () => {\n    listeners.delete(callback);\n    delAtom(state, atom);\n  };\n};\n/*\nexport {\n  unstable_createMutableSource as createMutableSource,\n  unstable_useMutableSource as useMutableSource,\n} from 'react'\n*/\n\n\nconst TARGET = Symbol();\nconst GET_VERSION = Symbol();\n\nconst createMutableSource = (target, getVersion) => ({\n  [TARGET]: target,\n  [GET_VERSION]: getVersion\n});\n\nconst useMutableSource = (source, getSnapshot, subscribe) => {\n  const lastVersion = useRef(0);\n  const currentVersion = source[GET_VERSION](source[TARGET]);\n  const [state, setState] = useState(() => [\n  /* [0] */\n  source,\n  /* [1] */\n  getSnapshot,\n  /* [2] */\n  subscribe,\n  /* [3] */\n  currentVersion,\n  /* [4] */\n  getSnapshot(source[TARGET])]);\n  let currentSnapshot = state[4];\n\n  if (state[0] !== source || state[1] !== getSnapshot || state[2] !== subscribe) {\n    currentSnapshot = getSnapshot(source[TARGET]);\n    setState([\n    /* [0] */\n    source,\n    /* [1] */\n    getSnapshot,\n    /* [2] */\n    subscribe,\n    /* [3] */\n    currentVersion,\n    /* [4] */\n    currentSnapshot]);\n  } else if (currentVersion !== state[3] && currentVersion !== lastVersion.current) {\n    currentSnapshot = getSnapshot(source[TARGET]);\n\n    if (!Object.is(currentSnapshot, state[4])) {\n      setState([\n      /* [0] */\n      source,\n      /* [1] */\n      getSnapshot,\n      /* [2] */\n      subscribe,\n      /* [3] */\n      currentVersion,\n      /* [4] */\n      currentSnapshot]);\n    }\n  }\n\n  useEffect(() => {\n    let didUnsubscribe = false;\n\n    const checkForUpdates = () => {\n      if (didUnsubscribe) {\n        return;\n      }\n\n      try {\n        const nextSnapshot = getSnapshot(source[TARGET]);\n        const nextVersion = source[GET_VERSION](source[TARGET]);\n        lastVersion.current = nextVersion;\n        setState(prev => {\n          if (prev[0] !== source || prev[1] !== getSnapshot || prev[2] !== subscribe) {\n            return prev;\n          }\n\n          if (Object.is(prev[4], nextSnapshot)) {\n            return prev;\n          }\n\n          return [\n          /* [0] */\n          prev[0],\n          /* [1] */\n          prev[1],\n          /* [2] */\n          prev[2],\n          /* [3] */\n          nextVersion,\n          /* [4] */\n          nextSnapshot];\n        });\n      } catch (e) {\n        // schedule update\n        setState(prev => [...prev]);\n      }\n    };\n\n    const unsubscribe = subscribe(source[TARGET], checkForUpdates);\n    checkForUpdates();\n    return () => {\n      didUnsubscribe = true;\n      unsubscribe();\n    };\n  }, [source, getSnapshot, subscribe]);\n  return currentSnapshot;\n};\n\nconst createStore = (initialValues, newAtomReceiver) => {\n  const state = createState(initialValues, newAtomReceiver);\n  const mutableSource = createMutableSource(state, () => state.v);\n\n  const updateAtom = (atom, update) => writeAtom(state, atom, update);\n\n  return [mutableSource, updateAtom];\n};\n\nconst StoreContextMap = new Map();\n\nconst getStoreContext = scope => {\n  if (!StoreContextMap.has(scope)) {\n    StoreContextMap.set(scope, createContext(createStore()));\n  }\n\n  return StoreContextMap.get(scope);\n};\n\nconst Provider = ({\n  initialValues,\n  scope,\n  children\n}) => {\n  const storeRef = useRef(null);\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {\n    /* eslint-disable react-hooks/rules-of-hooks */\n    const atomsRef = useRef([]);\n\n    if (storeRef.current === null) {\n      // lazy initialization\n      storeRef.current = createStore(initialValues, newAtom => {\n        atomsRef.current.push(newAtom);\n      });\n    }\n\n    useDebugState(storeRef.current, atomsRef.current);\n    /* eslint-enable react-hooks/rules-of-hooks */\n  } else {\n    if (storeRef.current === null) {\n      // lazy initialization\n      storeRef.current = createStore(initialValues);\n    }\n  }\n\n  const StoreContext = getStoreContext(scope);\n  return createElement(StoreContext.Provider, {\n    value: storeRef.current\n  }, children);\n};\n\nconst atomToPrintable = atom => atom.debugLabel || atom.toString();\n\nconst stateToPrintable = ([state, atoms]) => Object.fromEntries(atoms.flatMap(atom => {\n  const mounted = state.m.get(atom);\n\n  if (!mounted) {\n    return [];\n  }\n\n  const dependents = mounted.d;\n  const atomState = state.a.get(atom) || {};\n  return [[atomToPrintable(atom), {\n    value: atomState.e || atomState.p || atomState.w || atomState.v,\n    dependents: Array.from(dependents).map(atomToPrintable)\n  }]];\n}));\n\nconst getState = state => _extends({}, state); // shallow copy\n// We keep a reference to the atoms in Provider's atomsRef in dev mode,\n// so atoms aren't garbage collected by the WeakMap of mounted atoms\n\n\nconst useDebugState = (store, atoms) => {\n  const subscribe = useCallback((state, callback) => {\n    // FIXME we don't need to resubscribe, just need to subscribe for new one\n    const unsubs = atoms.map(atom => subscribeAtom(state, atom, callback));\n    return () => {\n      unsubs.forEach(unsub => unsub());\n    };\n  }, [atoms]);\n  const state = useMutableSource(store[0], getState, subscribe);\n  useDebugValue([state, atoms], stateToPrintable);\n};\n\nlet keyCount = 0; // global key count for all atoms\n\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = get => get(config);\n\n    config.write = (get, set, update) => {\n      set(config, typeof update === 'function' ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nconst isWritable = atom => !!atom.write;\n\nfunction useAtom(atom) {\n  const getAtomValue = useCallback(state => {\n    const atomState = readAtom(state, atom);\n\n    if (atomState.e) {\n      throw atomState.e; // read error\n    }\n\n    if (atomState.p) {\n      throw atomState.p; // read promise\n    }\n\n    if (atomState.w) {\n      throw atomState.w; // write promise\n    }\n\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error('no atom value');\n  }, [atom]);\n  const subscribe = useCallback((state, callback) => subscribeAtom(state, atom, callback), [atom]);\n  const StoreContext = getStoreContext(atom.scope);\n  const [mutableSource, updateAtom] = useContext(StoreContext);\n  const value = useMutableSource(mutableSource, getAtomValue, subscribe);\n  const setAtom = useCallback(update => {\n    if (isWritable(atom)) {\n      return updateAtom(atom, update);\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [updateAtom, atom]);\n  useDebugValue(value);\n  return [value, setAtom];\n}\n\nexport { Provider, getStoreContext as SECRET_INTERNAL_getStoreContext, atom, useAtom };","map":{"version":3,"sources":["/Users/danio/Documents/Bootcamp/Class/Homework/Portfolio_V.4/portfolio_v4/node_modules/jotai/index.module.js"],"names":["useRef","useState","useEffect","createContext","createElement","useCallback","useDebugValue","useContext","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","hasInitialValue","atom","createState","initialValues","newAtomReceiver","state","n","v","a","WeakMap","m","p","Set","value","atomState","r","d","Map","process","env","NODE_ENV","freeze","set","getAtomState","get","wipAtomState","dependencies","nextAtomState","Array","from","map","_getAtomState$r","_getAtomState","init","setAtomValue","promise","prevDependencies","e","is","commitAtomState","mountDependencies","setAtomReadError","error","setAtomReadPromise","setAtomInvalidated","setAtomWritePromise","w","scheduleReadAtomState","then","readAtomState","force","forEach","_","aState","entries","every","promiseOrValue","read","add","Error","Promise","flushPending","catch","errorOrPromise","readAtom","readingAtom","delete","addAtom","addingAtom","mounted","mountAtom","canUnmountAtom","l","size","has","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","pendingPromises","isPendingPromisesExpired","push","promiseOrVoid","write","console","warn","_resolve","reject","writeAtom","writingAtom","resolve","splice","loop","all","isActuallyWritableAtom","initialDependent","u","undefined","onMount","setAtom","_state$m$get","onUnmount","keys","dependents","isNewAtom","listener","clear","subscribeAtom","callback","listeners","TARGET","Symbol","GET_VERSION","createMutableSource","getVersion","useMutableSource","getSnapshot","subscribe","lastVersion","currentVersion","setState","currentSnapshot","current","didUnsubscribe","checkForUpdates","nextSnapshot","nextVersion","prev","unsubscribe","createStore","mutableSource","updateAtom","StoreContextMap","getStoreContext","scope","Provider","children","storeRef","atomsRef","newAtom","useDebugState","StoreContext","atomToPrintable","debugLabel","toString","stateToPrintable","atoms","fromEntries","flatMap","getState","store","unsubs","unsub","keyCount","config","isWritable","useAtom","getAtomValue","SECRET_INTERNAL_getStoreContext"],"mappings":"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","sourcesContent":["import { useRef, useState, useEffect, createContext, createElement, useCallback, useDebugValue, useContext } from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nconst hasInitialValue = atom => 'init' in atom;\n\nconst createState = (initialValues, newAtomReceiver) => {\n  const state = {\n    n: newAtomReceiver,\n    v: 0,\n    a: new WeakMap(),\n    m: new WeakMap(),\n    p: new Set()\n  };\n\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        d: new Map()\n      };\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n      }\n\n      state.a.set(atom, atomState);\n    }\n  }\n\n  return state;\n};\n\nconst getAtomState = (state, atom) => state.a.get(atom);\n\nconst wipAtomState = (state, atom, dependencies) => {\n  const atomState = getAtomState(state, atom);\n\n  const nextAtomState = _extends({\n    r: 0\n  }, atomState, {\n    d: dependencies ? new Map(Array.from(dependencies).map(a => {\n      var _getAtomState$r, _getAtomState;\n\n      return [a, (_getAtomState$r = (_getAtomState = getAtomState(state, a)) == null ? void 0 : _getAtomState.r) != null ? _getAtomState$r : 0];\n    })) : atomState ? atomState.d : new Map()\n  });\n\n  if (!atomState && hasInitialValue(atom)) {\n    nextAtomState.v = atom.init;\n  }\n\n  return [nextAtomState, atomState == null ? void 0 : atomState.d];\n};\n\nconst setAtomValue = (state, atom, value, dependencies, promise) => {\n  const [atomState, prevDependencies] = wipAtomState(state, atom, dependencies);\n\n  if (promise && promise !== (atomState == null ? void 0 : atomState.p)) {\n    // newer async read is running, not updating\n    return;\n  }\n\n  delete atomState.e; // read error\n\n  delete atomState.p; // read promise\n\n  delete atomState.i; // invalidated revision\n\n  if (!('v' in atomState) || !Object.is(atomState.v, value)) {\n    atomState.v = value;\n    ++atomState.r; // increment revision\n  }\n\n  commitAtomState(state, atom, atomState);\n  mountDependencies(state, atom, atomState, prevDependencies);\n};\n\nconst setAtomReadError = (state, atom, error, dependencies, promise) => {\n  const [atomState, prevDependencies] = wipAtomState(state, atom, dependencies);\n\n  if (promise && promise !== (atomState == null ? void 0 : atomState.p)) {\n    // newer async read is running, not updating\n    return;\n  }\n\n  delete atomState.p; // read promise\n\n  delete atomState.i; // invalidated revision\n\n  atomState.e = error; // read error\n\n  commitAtomState(state, atom, atomState);\n  mountDependencies(state, atom, atomState, prevDependencies);\n};\n\nconst setAtomReadPromise = (state, atom, promise, dependencies) => {\n  const [atomState, prevDependencies] = wipAtomState(state, atom, dependencies);\n  atomState.p = promise; // read promise\n\n  commitAtomState(state, atom, atomState);\n  mountDependencies(state, atom, atomState, prevDependencies);\n};\n\nconst setAtomInvalidated = (state, atom) => {\n  const [atomState] = wipAtomState(state, atom);\n  atomState.i = atomState.r; // invalidated revision\n\n  commitAtomState(state, atom, atomState);\n};\n\nconst setAtomWritePromise = (state, atom, promise) => {\n  const [atomState] = wipAtomState(state, atom);\n\n  if (promise) {\n    atomState.w = promise;\n  } else {\n    delete atomState.w; // write promise\n  }\n\n  commitAtomState(state, atom, atomState);\n};\n\nconst scheduleReadAtomState = (state, atom, promise) => {\n  promise.then(() => {\n    readAtomState(state, atom, true);\n  });\n};\n\nconst readAtomState = (state, atom, force) => {\n  if (!force) {\n    const atomState = getAtomState(state, atom);\n\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const aState = getAtomState(state, a);\n\n          if (aState && !aState.e && // no read error\n          !aState.p && // no read promise\n          aState.r === aState.i // revision is invalidated\n          ) {\n              readAtomState(state, a, true);\n            }\n        }\n      });\n\n      if (Array.from(atomState.d.entries()).every(([a, r]) => {\n        const aState = getAtomState(state, a);\n        return aState && !aState.e && // no read error\n        !aState.p && // no read promise\n        aState.r !== aState.i && // revision is not invalidated\n        aState.r === r // revision is equal to the last one\n        ;\n      })) {\n        return atomState;\n      }\n    }\n  }\n\n  let error;\n  let promise;\n  let value;\n  const dependencies = new Set();\n\n  try {\n    const promiseOrValue = atom.read(a => {\n      dependencies.add(a);\n\n      if (a !== atom) {\n        const aState = readAtomState(state, a);\n\n        if (aState.e) {\n          throw aState.e; // read error\n        }\n\n        if (aState.p) {\n          throw aState.p; // read promise\n        }\n\n        return aState.v; // value\n      } // a === atom\n\n\n      const aState = getAtomState(state, a);\n\n      if (aState) {\n        if (aState.p) {\n          throw aState.p; // read promise\n        }\n\n        return aState.v; // value\n      }\n\n      if (hasInitialValue(a)) {\n        return a.init;\n      }\n\n      throw new Error('no atom init');\n    });\n\n    if (promiseOrValue instanceof Promise) {\n      promise = promiseOrValue.then(value => {\n        setAtomValue(state, atom, value, dependencies, promise);\n        flushPending(state);\n      }).catch(e => {\n        if (e instanceof Promise) {\n          scheduleReadAtomState(state, atom, e);\n          return e;\n        }\n\n        setAtomReadError(state, atom, e instanceof Error ? e : new Error(e), dependencies, promise);\n        flushPending(state);\n      });\n    } else {\n      value = promiseOrValue;\n    }\n  } catch (errorOrPromise) {\n    if (errorOrPromise instanceof Promise) {\n      scheduleReadAtomState(state, atom, errorOrPromise);\n      promise = errorOrPromise;\n    } else if (errorOrPromise instanceof Error) {\n      error = errorOrPromise;\n    } else {\n      error = new Error(errorOrPromise);\n    }\n  }\n\n  if (error) {\n    setAtomReadError(state, atom, error, dependencies);\n  } else if (promise) {\n    setAtomReadPromise(state, atom, promise, dependencies);\n  } else {\n    setAtomValue(state, atom, value, dependencies);\n  }\n\n  return getAtomState(state, atom);\n};\n\nconst readAtom = (state, readingAtom) => {\n  const atomState = readAtomState(state, readingAtom);\n  state.p.delete(readingAtom);\n  flushPending(state);\n  return atomState;\n};\n\nconst addAtom = (state, addingAtom) => {\n  let mounted = state.m.get(addingAtom);\n\n  if (!mounted) {\n    mounted = mountAtom(state, addingAtom);\n  }\n\n  flushPending(state);\n  return mounted;\n}; // XXX doesn't work with mutally dependent atoms\n\n\nconst canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.d.size || mounted.d.size === 1 && mounted.d.has(atom));\n\nconst delAtom = (state, deletingAtom) => {\n  const mounted = state.m.get(deletingAtom);\n\n  if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n    unmountAtom(state, deletingAtom);\n  }\n\n  flushPending(state);\n};\n\nconst invalidateDependents = (state, atom) => {\n  const mounted = state.m.get(atom);\n  mounted == null ? void 0 : mounted.d.forEach(dependent => {\n    if (dependent === atom) {\n      return;\n    }\n\n    setAtomInvalidated(state, dependent);\n    invalidateDependents(state, dependent);\n  });\n};\n\nconst writeAtomState = (state, atom, update, pendingPromises) => {\n  const isPendingPromisesExpired = !pendingPromises.length;\n  const atomState = getAtomState(state, atom);\n\n  if (atomState && atomState.w // write promise\n  ) {\n      const promise = atomState.w.then(() => {\n        writeAtomState(state, atom, update, pendingPromises);\n\n        if (isPendingPromisesExpired) {\n          flushPending(state);\n        }\n      });\n\n      if (!isPendingPromisesExpired) {\n        pendingPromises.push(promise);\n      }\n\n      return;\n    }\n\n  try {\n    const promiseOrVoid = atom.write(a => {\n      const aState = readAtomState(state, a);\n\n      if (aState.e) {\n        throw aState.e; // read error\n      }\n\n      if (aState.p) {\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          console.warn('Reading pending atom state in write operation. We throw a promise for now.', a);\n        }\n\n        throw aState.p; // read promise\n      }\n\n      if ('v' in aState) {\n        return aState.v; // value\n      }\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] no value found while reading atom in write operation. This probably a bug.', a);\n      }\n\n      throw new Error('no value found');\n    }, (a, v) => {\n      if (a === atom) {\n        setAtomValue(state, a, v);\n        invalidateDependents(state, a);\n      } else {\n        const isPendingPromisesExpired = !pendingPromises.length;\n        writeAtomState(state, a, v, pendingPromises);\n\n        if (isPendingPromisesExpired) {\n          flushPending(state);\n        }\n      }\n    }, update);\n\n    if (promiseOrVoid instanceof Promise) {\n      const promise = promiseOrVoid.then(() => {\n        setAtomWritePromise(state, atom);\n\n        if (isPendingPromisesExpired) {\n          flushPending(state);\n        }\n      });\n\n      if (!isPendingPromisesExpired) {\n        pendingPromises.push(promise);\n      }\n\n      setAtomWritePromise(state, atom, promise);\n    }\n  } catch (e) {\n    if (pendingPromises.length === 1) {\n      // still in sync, throw it right away\n      throw e;\n    } else if (!isPendingPromisesExpired) {\n      pendingPromises.push(new Promise((_resolve, reject) => {\n        reject(e);\n      }));\n    } else {\n      console.error('Uncaught exception: Use promise to catch error', e);\n    }\n  }\n};\n\nconst writeAtom = (state, writingAtom, update) => {\n  const pendingPromises = [Promise.resolve()];\n  writeAtomState(state, writingAtom, update, pendingPromises);\n  flushPending(state);\n\n  if (pendingPromises.length <= 1) {\n    pendingPromises.splice(0);\n  } else {\n    return new Promise((resolve, reject) => {\n      const loop = () => {\n        if (pendingPromises.length <= 1) {\n          pendingPromises.splice(0);\n          resolve();\n        } else {\n          Promise.all(pendingPromises).then(() => {\n            pendingPromises.splice(1);\n            flushPending(state);\n            loop();\n          }).catch(reject);\n        }\n      };\n\n      loop();\n    });\n  }\n};\n\nconst isActuallyWritableAtom = atom => !!atom.write;\n\nconst mountAtom = (state, atom, initialDependent) => {\n  // mount dependencies beforehand\n  const atomState = getAtomState(state, atom);\n\n  if (atomState) {\n    atomState.d.forEach((_, a) => {\n      if (a !== atom) {\n        // check if not mounted\n        if (!state.m.has(a)) {\n          mountAtom(state, a, atom);\n        }\n      }\n    });\n  } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    console.warn('[Bug] could not find atom state to mount', atom);\n  } // mount self\n\n\n  const mounted = {\n    d: new Set(initialDependent && [initialDependent]),\n    l: new Set(),\n    u: undefined\n  };\n  state.m.set(atom, mounted);\n\n  if (isActuallyWritableAtom(atom) && atom.onMount) {\n    const setAtom = update => writeAtom(state, atom, update);\n\n    mounted.u = atom.onMount(setAtom);\n  }\n\n  return mounted;\n};\n\nconst unmountAtom = (state, atom) => {\n  var _state$m$get;\n\n  // unmount self\n  const onUnmount = (_state$m$get = state.m.get(atom)) == null ? void 0 : _state$m$get.u;\n\n  if (onUnmount) {\n    onUnmount();\n  }\n\n  state.m.delete(atom); // unmount dependencies afterward\n\n  const atomState = getAtomState(state, atom);\n\n  if (atomState) {\n    if (atomState.p && // read promise\n    typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] deleting atomState with read promise', atom);\n    }\n\n    atomState.d.forEach((_, a) => {\n      if (a !== atom) {\n        const mounted = state.m.get(a);\n\n        if (mounted) {\n          mounted.d.delete(atom);\n\n          if (canUnmountAtom(a, mounted)) {\n            unmountAtom(state, a);\n          }\n        }\n      }\n    });\n  } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    console.warn('[Bug] could not find atom state to unmount', atom);\n  }\n};\n\nconst mountDependencies = (state, atom, atomState, prevDependencies) => {\n  if (prevDependencies !== atomState.d) {\n    const dependencies = new Set(atomState.d.keys());\n\n    if (prevDependencies) {\n      prevDependencies.forEach((_, a) => {\n        const mounted = state.m.get(a);\n\n        if (dependencies.has(a)) {\n          // not changed\n          dependencies.delete(a);\n        } else if (mounted) {\n          mounted.d.delete(atom);\n\n          if (canUnmountAtom(a, mounted)) {\n            unmountAtom(state, a);\n          }\n        } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          console.warn('[Bug] a dependency is not mounted', a);\n        }\n      });\n    }\n\n    dependencies.forEach(a => {\n      const mounted = state.m.get(a);\n\n      if (mounted) {\n        const dependents = mounted.d;\n        dependents.add(atom);\n      } else {\n        mountAtom(state, a, atom);\n      }\n    });\n  }\n};\n\nconst commitAtomState = (state, atom, atomState) => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    Object.freeze(atomState);\n  }\n\n  const isNewAtom = state.n && !state.a.has(atom);\n  state.a.set(atom, atomState);\n\n  if (isNewAtom) {\n    state.n(atom);\n  }\n\n  ++state.v;\n  state.p.add(atom);\n};\n\nconst flushPending = state => {\n  state.p.forEach(atom => {\n    const mounted = state.m.get(atom);\n    mounted == null ? void 0 : mounted.l.forEach(listener => listener());\n  });\n  state.p.clear();\n};\n\nconst subscribeAtom = (state, atom, callback) => {\n  const mounted = addAtom(state, atom);\n  const listeners = mounted.l;\n  listeners.add(callback);\n  return () => {\n    listeners.delete(callback);\n    delAtom(state, atom);\n  };\n};\n\n/*\nexport {\n  unstable_createMutableSource as createMutableSource,\n  unstable_useMutableSource as useMutableSource,\n} from 'react'\n*/\nconst TARGET = Symbol();\nconst GET_VERSION = Symbol();\nconst createMutableSource = (target, getVersion) => ({\n  [TARGET]: target,\n  [GET_VERSION]: getVersion\n});\nconst useMutableSource = (source, getSnapshot, subscribe) => {\n  const lastVersion = useRef(0);\n  const currentVersion = source[GET_VERSION](source[TARGET]);\n  const [state, setState] = useState(() => [\n  /* [0] */\n  source,\n  /* [1] */\n  getSnapshot,\n  /* [2] */\n  subscribe,\n  /* [3] */\n  currentVersion,\n  /* [4] */\n  getSnapshot(source[TARGET])]);\n  let currentSnapshot = state[4];\n\n  if (state[0] !== source || state[1] !== getSnapshot || state[2] !== subscribe) {\n    currentSnapshot = getSnapshot(source[TARGET]);\n    setState([\n    /* [0] */\n    source,\n    /* [1] */\n    getSnapshot,\n    /* [2] */\n    subscribe,\n    /* [3] */\n    currentVersion,\n    /* [4] */\n    currentSnapshot]);\n  } else if (currentVersion !== state[3] && currentVersion !== lastVersion.current) {\n    currentSnapshot = getSnapshot(source[TARGET]);\n\n    if (!Object.is(currentSnapshot, state[4])) {\n      setState([\n      /* [0] */\n      source,\n      /* [1] */\n      getSnapshot,\n      /* [2] */\n      subscribe,\n      /* [3] */\n      currentVersion,\n      /* [4] */\n      currentSnapshot]);\n    }\n  }\n\n  useEffect(() => {\n    let didUnsubscribe = false;\n\n    const checkForUpdates = () => {\n      if (didUnsubscribe) {\n        return;\n      }\n\n      try {\n        const nextSnapshot = getSnapshot(source[TARGET]);\n        const nextVersion = source[GET_VERSION](source[TARGET]);\n        lastVersion.current = nextVersion;\n        setState(prev => {\n          if (prev[0] !== source || prev[1] !== getSnapshot || prev[2] !== subscribe) {\n            return prev;\n          }\n\n          if (Object.is(prev[4], nextSnapshot)) {\n            return prev;\n          }\n\n          return [\n          /* [0] */\n          prev[0],\n          /* [1] */\n          prev[1],\n          /* [2] */\n          prev[2],\n          /* [3] */\n          nextVersion,\n          /* [4] */\n          nextSnapshot];\n        });\n      } catch (e) {\n        // schedule update\n        setState(prev => [...prev]);\n      }\n    };\n\n    const unsubscribe = subscribe(source[TARGET], checkForUpdates);\n    checkForUpdates();\n    return () => {\n      didUnsubscribe = true;\n      unsubscribe();\n    };\n  }, [source, getSnapshot, subscribe]);\n  return currentSnapshot;\n};\n\nconst createStore = (initialValues, newAtomReceiver) => {\n  const state = createState(initialValues, newAtomReceiver);\n  const mutableSource = createMutableSource(state, () => state.v);\n\n  const updateAtom = (atom, update) => writeAtom(state, atom, update);\n\n  return [mutableSource, updateAtom];\n};\nconst StoreContextMap = new Map();\nconst getStoreContext = scope => {\n  if (!StoreContextMap.has(scope)) {\n    StoreContextMap.set(scope, createContext(createStore()));\n  }\n\n  return StoreContextMap.get(scope);\n};\n\nconst Provider = ({\n  initialValues,\n  scope,\n  children\n}) => {\n  const storeRef = useRef(null);\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {\n    /* eslint-disable react-hooks/rules-of-hooks */\n    const atomsRef = useRef([]);\n\n    if (storeRef.current === null) {\n      // lazy initialization\n      storeRef.current = createStore(initialValues, newAtom => {\n        atomsRef.current.push(newAtom);\n      });\n    }\n\n    useDebugState(storeRef.current, atomsRef.current);\n    /* eslint-enable react-hooks/rules-of-hooks */\n  } else {\n    if (storeRef.current === null) {\n      // lazy initialization\n      storeRef.current = createStore(initialValues);\n    }\n  }\n\n  const StoreContext = getStoreContext(scope);\n  return createElement(StoreContext.Provider, {\n    value: storeRef.current\n  }, children);\n};\n\nconst atomToPrintable = atom => atom.debugLabel || atom.toString();\n\nconst stateToPrintable = ([state, atoms]) => Object.fromEntries(atoms.flatMap(atom => {\n  const mounted = state.m.get(atom);\n\n  if (!mounted) {\n    return [];\n  }\n\n  const dependents = mounted.d;\n  const atomState = state.a.get(atom) || {};\n  return [[atomToPrintable(atom), {\n    value: atomState.e || atomState.p || atomState.w || atomState.v,\n    dependents: Array.from(dependents).map(atomToPrintable)\n  }]];\n}));\n\nconst getState = state => _extends({}, state); // shallow copy\n// We keep a reference to the atoms in Provider's atomsRef in dev mode,\n// so atoms aren't garbage collected by the WeakMap of mounted atoms\n\n\nconst useDebugState = (store, atoms) => {\n  const subscribe = useCallback((state, callback) => {\n    // FIXME we don't need to resubscribe, just need to subscribe for new one\n    const unsubs = atoms.map(atom => subscribeAtom(state, atom, callback));\n    return () => {\n      unsubs.forEach(unsub => unsub());\n    };\n  }, [atoms]);\n  const state = useMutableSource(store[0], getState, subscribe);\n  useDebugValue([state, atoms], stateToPrintable);\n};\n\nlet keyCount = 0; // global key count for all atoms\n\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = get => get(config);\n\n    config.write = (get, set, update) => {\n      set(config, typeof update === 'function' ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nconst isWritable = atom => !!atom.write;\n\nfunction useAtom(atom) {\n  const getAtomValue = useCallback(state => {\n    const atomState = readAtom(state, atom);\n\n    if (atomState.e) {\n      throw atomState.e; // read error\n    }\n\n    if (atomState.p) {\n      throw atomState.p; // read promise\n    }\n\n    if (atomState.w) {\n      throw atomState.w; // write promise\n    }\n\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error('no atom value');\n  }, [atom]);\n  const subscribe = useCallback((state, callback) => subscribeAtom(state, atom, callback), [atom]);\n  const StoreContext = getStoreContext(atom.scope);\n  const [mutableSource, updateAtom] = useContext(StoreContext);\n  const value = useMutableSource(mutableSource, getAtomValue, subscribe);\n  const setAtom = useCallback(update => {\n    if (isWritable(atom)) {\n      return updateAtom(atom, update);\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [updateAtom, atom]);\n  useDebugValue(value);\n  return [value, setAtom];\n}\n\nexport { Provider, getStoreContext as SECRET_INTERNAL_getStoreContext, atom, useAtom };\n"]},"metadata":{},"sourceType":"module"}